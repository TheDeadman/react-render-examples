// AUTO-GENERATED by generate-snippets.js on 2025-10-17T15:59:41.866Z
// Source: MemoizedComponentsExample.tsx
// Do not edit this file directly.

const snippet = `// Generate Snippet
import { useState, useMemo, useCallback } from 'react';
import { Box, Typography, Container, Grid } from '@mui/material';
import RenderCount from '../../overall/RenderCount';
import CodeViewer from './CodeViewer';
import RegularChild, {
    explanation as regularChildExplanation,
} from './components/RegularChild';
import MemoizedChild, {
    explanation as memoizedChildExplanation,
} from './components/MemoizedChild';
import MemoizedChildWithBadCallback, {
    explanation as memoizedChildWithBadCallbackExplanation,
} from './components/MemoizedChildWithBadCallback';
import ExpensiveComponentBad, {
    explanation as expensiveComponentBadExplanation,
} from './components/ExpensiveComponentBad';
import ExpensiveComponentGood, {
    explanation as expensiveComponentGoodExplanation,
} from './components/ExpensiveComponentGood';
import ComponentLabel from './components/ComponentLabel';
import ColorLegend from './components/ColorLegend';
import ParentControls from './components/ParentControls';
import ObservationGuide from './ObservationGuide';
import parentComponentSnippet from './snippets/memoizedComponentsExample.snippet';
import regularChildSnippet from './snippets/components/regularChild.snippet';
import memoizedChildSnippet from './snippets/components/memoizedChild.snippet';
import memoizedChildWithBadCallbackSnippet from './snippets/components/memoizedChildWithBadCallback.snippet';
import expensiveComponentBadSnippet from './snippets/components/expensiveComponentBad.snippet';
import expensiveComponentGoodSnippet from './snippets/components/expensiveComponentGood.snippet';
import styles from 'MemoizedComponents.module.scss';

const MemoizedComponentsExample = () => {
    const [count1, setCount1] = useState(0);
    const [multiplier, setMultiplier] = useState(1);
    const [unrelatedState, setUnrelatedState] = useState('');

    // Without useCallback - this creates a new function on every render
    const handleIncrement1Bad = () => setCount1((prev) => prev + 1);

    // With useCallback - this function is memoized
    const handleIncrement2 = useCallback(
        () => setCount1((prev) => prev + 1),
        [],
    );

    // Expensive computation that only depends on count1
    const expensiveValue = useMemo(() => {
        console.log('Computing expensive value...');
        return count1 * 1000;
    }, [count1]);

    return (
        <Container maxWidth="lg">
            <ParentControls
                unrelatedState={unrelatedState}
                onUnrelatedStateChange={setUnrelatedState}
                multiplier={multiplier}
                onMultiplierChange={setMultiplier}
                count1={count1}
            />
            <RegularChild
                value={count1}
                onIncrement={handleIncrement1Bad}
                expensiveValue={expensiveValue}
            />
            <MemoizedChildWithBadCallback
                value={count1}
                onIncrement={handleIncrement1Bad} // Same non-memoized function
                expensiveValue={expensiveValue}
            />
            <MemoizedChild
                value={count1}
                onIncrement={handleIncrement2}
                expensiveValue={expensiveValue}
            />
            <ExpensiveComponentBad multiplier={multiplier} />
            <ExpensiveComponentGood multiplier={multiplier} />
        </Container>
    );
};

export default MemoizedComponentsExample;
`;

export default snippet;
