// AUTO-GENERATED by generate-snippets.js
// Contains explanation exports extracted from snippet sources
//   components\ExpensiveComponentBad.tsx
//   components\ExpensiveComponentGood.tsx
//   components\MemoizedChild.tsx
//   components\MemoizedChildWithBadCallback.tsx
//   MemoizedComponentsExample.tsx
//   components\ParentControls.tsx
//   components\RegularChild.tsx

export const expensiveComponentBadExplanation =
    "This component demonstrates what happens WITHOUT useMemo in a calculated value. The expensive calculation runs on every render. Notice how it logs to the console every time you type in the 'Unrelated State' field.";
export const expensiveComponentGoodExplanation =
    "This component uses useMemo() to memoize the expensive calculation. It only recalculates when the 'multiplier' dependency actually changes, not on every render. Type in 'Unrelated State' vs changing the multiplier to see the difference in console logs.";
export const memoizedChildExplanation =
    'This component is wrapped in React.memo() AND receives a memoized callback (useCallback). It only re-renders when its props actually change. Both conditions are necessary - React.memo() for shallow prop comparison + useCallback() for stable function references.';
export const memoizedChildWithBadCallbackExplanation =
    'Even though this component is wrapped in React.memo(), it still re-renders every time because it receives a new function reference (handleIncrement1Bad) on each render. React.memo() does shallow comparison - if any prop changes (including function references), it re-renders. This demonstrates why useCallback() and useMemo() are essential when using React.memo().';
export const memoizedComponentsExampleExplanation =
    'The parent component shows the complete optimization strategy: useCallback() prevents function recreation, useMemo() prevents expensive recalculations, and the child components use React.memo(). The key insight: ALL THREE hooks must work together. Failure to use React.memo, useCallback, or useMemo will break the optimization chain in many cases.';
export const parentControlsExplanation =
    "Parent component controls state that affects child components. Changing 'Unrelated State' triggers all child renders, while changing 'Multiplier' affects only those depending on it.";
export const regularChildExplanation =
    "This component re-renders every time the parent re-renders because it's NOT wrapped in React.memo(). Without memo, React always re-renders child components when the parent re-renders, regardless of whether props have changed.";
