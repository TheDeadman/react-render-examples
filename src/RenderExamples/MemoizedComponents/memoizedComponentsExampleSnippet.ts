// AUTO-GENERATED by generate-snippets.mjs on 2025-10-17T13:52:58.998Z
// Source: MemoizedComponentsExample.tsx
// Do not edit this file directly.

const snippet = `// Generate Snippet
import { useState, useMemo, useCallback } from 'react';
import { Box, Typography, Container, Grid } from '@mui/material';
import RenderCount from '../../overall/RenderCount';
import CodeViewer from './CodeViewer';
import { codeSnippets, explanations } from './codeSnippets';
import RegularChild from './components/RegularChild';
import MemoizedChild from './components/MemoizedChild';
import MemoizedChildWithBadCallback from './components/MemoizedChildWithBadCallback';
import ExpensiveComponentBad from './components/ExpensiveComponentBad';
import ExpensiveComponentGood from './components/ExpensiveComponentGood';
import ComponentLabel from './components/ComponentLabel';
import ColorLegend from './components/ColorLegend';
import ParentControls from './components/ParentControls';
import ObservationGuide from './ObservationGuide';
import styles from 'MemoizedComponents.module.scss';

const MemoizedComponentsExample = () => {
    const [count1, setCount1] = useState(0);
    const [multiplier, setMultiplier] = useState(1);
    const [unrelatedState, setUnrelatedState] = useState('');

    // Without useCallback - this creates a new function on every render
    const handleIncrement1Bad = () => setCount1(prev => prev + 1);
    
    // With useCallback - this function is memoized
    const handleIncrement2 = useCallback(() => setCount1(prev => prev + 1), []);

    // Expensive computation that only depends on count1
    const expensiveValue = useMemo(() => {
        console.log('Computing expensive value...');
        return count1 * 1000;
    }, [count1]);

    return (
        <Container maxWidth="lg">
                        <ParentControls
                            unrelatedState={unrelatedState}
                            onUnrelatedStateChange={setUnrelatedState}
                            multiplier={multiplier}
                            onMultiplierChange={setMultiplier}
                            count1={count1}
                        />
                        <RegularChild 
                            value={count1} 
                            onIncrement={handleIncrement1Bad} 
                            expensiveValue={expensiveValue} 
                        />
                        <MemoizedChildWithBadCallback 
                            value={count1} 
                            onIncrement={handleIncrement1Bad}  // Same non-memoized function
                            expensiveValue={expensiveValue} 
                        />
                        <MemoizedChild 
                            value={count1} 
                            onIncrement={handleIncrement2} 
                            expensiveValue={expensiveValue} 
                        />
                        <ExpensiveComponentBad multiplier={multiplier} />
                        <ExpensiveComponentGood multiplier={multiplier} />
        </Container>
    );
};

export default MemoizedComponentsExample;`;

export default snippet;
