// AUTO-GENERATED by generate-snippets.js
// Contains explanation exports extracted from snippet sources
//   context.tsx
//   components\ExpensiveComponentBadContext.tsx
//   components\ExpensiveComponentGoodContext.tsx
//   components\MemoizedChildContext.tsx
//   components\MemoizedChildWithBadCallbackContext.tsx
//   MemoizedComponentsContextExample.tsx
//   components\ParentControlsContext.tsx
//   components\RegularChildContext.tsx

export const contextExplanation =
    'React Context creates a provider that shares state across components without prop drilling. However, when ANY value in the context changes, ALL consumers re-render because the context value object is recreated. This breaks React.memo() optimizations and can cause performance issues in large applications.';
export const expensiveComponentBadContextExplanation =
    'This component shows how expensive calculations can become even more problematic with Context. The calculation runs on every context change, not just when the relevant data changes. This is why you should be careful about what you put in context.';
export const expensiveComponentGoodContextExplanation =
    'useMemo() still works within components. Even though the component re-renders on every context change, the expensive calculation only runs when the multiplier dependency actually changes. This shows how to optimize expensive operations even in a context-heavy architecture.';
export const memoizedChildContextExplanation =
    'This demonstrates the key limitation of React Context: even though this component is wrapped in React.memo(), it still re-renders on EVERY context change. This happens because the context provider creates a new value object on each render, breaking memoization.';
export const memoizedChildWithBadCallbackContextExplanation =
    'This component shows that with Context, even the distinction between memoized and non-memoized functions becomes irrelevant for preventing re-renders. React.memo() is completely ineffective with Context because context consumers always re-render when the context value changes, regardless of optimization strategies.';
export const memoizedComponentsContextExampleExplanation =
    'The Context parent component demonstrates how React Context shifts state management from local state and props to a centralized provider. The provider wraps all consumers and manages shared state. Unlike props-based examples, child components get data directly from context rather than through prop passing.';
export const parentControlsContextExplanation = 'ph';
export const regularChildContextExplanation =
    "This component behaves the same as the props version - it re-renders on every context change because it's not wrapped in React.memo(). The difference is that it gets data from context instead of props.";
