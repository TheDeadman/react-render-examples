// AUTO-GENERATED by generate-snippets.js on 2025-10-23T16:57:07.739Z
// Contains explanation exports extracted from snippet sources
//   components\ExpensiveComponentBad.tsx
//   components\ExpensiveComponentGood.tsx
//   components\MemoizedChild.tsx
//   components\MemoizedChildWithBadCallback.tsx
//   memoizedComponents.slice.ts
//   MemoizedComponentsExample.tsx
//   components\ParentControls.tsx
//   components\RegularChild.tsx

export const expensiveComponentBadExplanation =
    'This component shows how an expensive calculation selector without memoization by "createSelector" reruns every time a piece of the slice state changes. Watch the console log to see the recalculation whenever multiplier updates.';
export const expensiveComponentGoodExplanation =
    'This component uses a memoized selector so the expensive calculation only recomputes when the multiplier dependency changes. It avoids unnecessary recalculations even when other Redux state updates.';
export const memoizedChildExplanation =
    'React.memo is unnecessary here because the component already uses useAppSelector to subscribe only to specific pieces of state. The parent does not re-render in this example. The component will re-render only when those selected values change.';
export const memoizedChildWithBadCallbackExplanation =
    "This is essentially the same as the Memoized Child Component. Because we can import our dispatch function and action function directly where needed, we don't need to pass it down as a prop. These functions also don't need to be memoized because they have stable references.";
export const memoizedComponents_sliceExplanation =
    "This redux slice abstracts the state management logic out of the components. The components can subscribe to the state that they use and be unaffected by other pieces of state. Note that calculated selectors will run on every state change for the slice but the components using them will only re-render if the result is different. This can be prevented by using createSelector to only run the calculation again if any of the 'input selectors' returns a different result.";
export const memoizedComponentsExampleExplanation =
    'The Redux parent component demonstrates lifting state into the store while child components subscribe only to the values they need. Each child uses useAppSelector or useAppDispatch instead of receiving props, highlighting selective rendering based on subscribed slices of state.';
export const parentControlsExplanation =
    "This redux slice abstracts the state management logic out of the components. The components can subscribe to the state that they use and be unaffected by other pieces of state. Note that calculated selectors will run on every state change for the slice but the components using them will only re-render if the result is different. This can be prevented by using createSelector to only run the calculation again if any of the 'input selectors' returns a different result.";
export const regularChildExplanation =
    'This component only re-renders when the subscribed state changes. The parent never re-renders in this example, so memoization is not needed here.';
