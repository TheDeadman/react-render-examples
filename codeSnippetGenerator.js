#!/usr/bin/env node
// generate-snippets.mjs
// Usage:
//   node generate-snippets.mjs [paths...]
// Examples:
//   node generate-snippets.mjs src/components
//   node generate-snippets.mjs .
//
// What it does:
//   For each React component file (default: .tsx, .jsx, .ts, .js),
//   it creates a sibling file named like "<lowerFirstBase>Snippet.ts"
//   that exports the component's source code as:
//     const snippet = `...`;
//     export default snippet;
//
//   Example: Dropdown.tsx  -> dropdownSnippet.ts
//
// Notes:
//   - Skips files that already look like snippet files (*Snippet.ts).
//   - Skips common test/story/typings files (.test., .spec., .stories., .d.ts).
//   - Escapes backticks and "${" to keep template literal intact.

import { promises as fs } from 'node:fs';
import path from 'node:path';

const exts = new Set([".tsx", ".jsx", ".ts", ".js"]);
const now = new Date().toISOString();

const args = process.argv.slice(2);
const roots = args.length ? args : [process.cwd()];

async function* walk(dir) {
  const entries = await fs.readdir(dir, { withFileTypes: true });
  for (const entry of entries) {
    const res = path.join(dir, entry.name);
    if (entry.isDirectory()) {
      // Skip node_modules and build output folders
      const lower = entry.name.toLowerCase();
      if (["node_modules", ".git", "dist", "build", ".next", "out"].includes(lower)) continue;
      yield* walk(res);
    } else {
      yield res;
    }
  }
}

function looksLikeSnippetFile(file) {
  return /Snippet\.ts$/.test(file);
}

function shouldSkip(file) {
  const base = path.basename(file);
  if (looksLikeSnippetFile(base)) return true;
  if (/\.(test|spec)\./i.test(base)) return true;
  if (/\.stories\./i.test(base)) return true;
  if (/\.d\.ts$/i.test(base)) return true;
  return false;
}

function lowerFirst(s) {
  return s.length ? s[0].toLowerCase() + s.slice(1) : s;
}

function targetPathFor(srcPath) {
  const dir = path.dirname(srcPath);
  const ext = path.extname(srcPath);
  if (!exts.has(ext)) return null;
  const base = path.basename(srcPath, ext);
  const outBase = `${lowerFirst(base)}Snippet.ts`;
  return path.join(dir, outBase);
}

function toTemplateLiteralSafe(content) {
  // Escape backticks and the start of template placeholders
  return content
    .replaceAll("`", "\\`")
    .replaceAll("${", "\\${");
}

function fileHeader(srcPath) {
  return `// AUTO-GENERATED by generate-snippets.mjs on ${now}\n// Source: ${path.basename(srcPath)}\n// Do not edit this file directly.\n`;
}

async function writeSnippet(srcPath, outPath, body) {
  const header = fileHeader(srcPath);
  const fileText = `${header}\nconst snippet = \`${toTemplateLiteralSafe(body)}\`;\n\nexport default snippet;\n`;

  try {
    // Only write if changed, to avoid touching timestamps unnecessarily
    const prev = await fs.readFile(outPath, "utf8").catch(() => null);
    if (prev !== null && prev === fileText) {
      return { outPath, status: "unchanged" };
    }
  } catch {}

  await fs.writeFile(outPath, fileText, "utf8");
  return { outPath, status: "written" };
}

async function processFile(file) {
  if (shouldSkip(file)) return null;
  const ext = path.extname(file);
  if (!exts.has(ext)) return null;

  const outPath = targetPathFor(file);
  if (!outPath) return null;

  try {
    const body = await fs.readFile(file, "utf8");
    const result = await writeSnippet(file, outPath, body);
    return { src: file, out: outPath, ...result };
  } catch (err) {
    return { src: file, error: String(err) };
  }
}

(async () => {
  const results = [];
  for (const root of roots) {
    for await (const file of walk(root)) {
      const r = await processFile(file);
      if (r) results.push(r);
    }
  }

  // Pretty print summary
  const grouped = results.reduce(
    (acc, r) => {
      if (r.error) acc.errors.push(r);
      else if (r.status === "written") acc.written.push(r);
      else if (r.status === "unchanged") acc.unchanged.push(r);
      return acc;
    },
    { written: [], unchanged: [], errors: [] }
  );

  const rel = (p) => path.relative(process.cwd(), p) || p;

  if (grouped.written.length) {
    console.log("\nCreated/Updated:");
    for (const r of grouped.written) console.log(`  ${rel(r.out)}  ‚Üê  ${rel(r.src)}`);
  }
  if (grouped.unchanged.length) {
    console.log("\nUnchanged:");
    for (const r of grouped.unchanged) console.log(`  ${rel(r.out)}  (from ${rel(r.src)})`);
  }
  if (grouped.errors.length) {
    console.error("\nErrors:");
    for (const r of grouped.errors) console.error(`  ${rel(r.src)}: ${r.error}`);
    process.exitCode = 1;
  }
})();
