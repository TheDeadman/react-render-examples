#!/usr/bin/env node
// generate-snippets.js
// Usage:
//   node generate-snippets.js [paths...]
//
// This version only generates a snippet if the source file begins with:
//   // Generate Snippet
// and removes lines between comment pairs:
//   // Remove START
//   // Remove END

import { promises as fs } from 'node:fs';
import path from 'node:path';
import prettier from 'prettier';

// Add JSX attribute names here to omit them from generated snippets.
const propertiesToRemove = ['className', 'variant'];
// List JSX component names whose elements should be stripped from snippets.
const componentsToRemove = ['RenderCount'];

function dataParserForExt(ext) {
  switch (ext) {
    case '.ts':
    case '.tsx':
      return 'typescript';
    case '.jsx':
      return 'babel';
    case '.js':
      return 'babel';
    default:
      return null;
  }
}

async function formatSnippetBody(content, ext) {
  const parser = dataParserForExt(ext);
  if (!parser) return content;

  try {
    return prettier.format(content, { parser, singleQuote: true, tabWidth: 4 });
  } catch {
    return content;
  }
}

const exts = new Set([".tsx", ".jsx", ".ts", ".js"]);
const now = new Date().toISOString();

const args = process.argv.slice(2);
const roots = args.length ? args : [process.cwd()];

async function* walk(dir) {
  const entries = await fs.readdir(dir, { withFileTypes: true });
  for (const entry of entries) {
    const res = path.join(dir, entry.name);
    if (entry.isDirectory()) {
      const lower = entry.name.toLowerCase();
      if (["node_modules", ".git", "dist", "build", ".next", "out", "snippets"].includes(lower)) continue;
      yield* walk(res);
    } else {
      yield res;
    }
  }
}

function looksLikeSnippetFile(file) {
  return /\.snippet\.ts$/i.test(file);
}

function shouldSkip(file) {
  const base = path.basename(file);
  if (looksLikeSnippetFile(base)) return true;
  if (/\.(test|spec)\./i.test(base)) return true;
  if (/\.stories\./i.test(base)) return true;
  if (/\.d\.ts$/i.test(base)) return true;
  return false;
}

function lowerFirst(s) {
  return s.length ? s[0].toLowerCase() + s.slice(1) : s;
}

function targetPathFor(root, srcPath) {
  const ext = path.extname(srcPath);
  if (!exts.has(ext)) return null;
  const relativePath = path.relative(root, srcPath);
  if (relativePath.startsWith('..')) return null;
  const dir = path.dirname(relativePath);
  const base = path.basename(relativePath, ext);
  const outBase = `${lowerFirst(base)}.snippet.ts`;
  const targetDir = dir === '.' ? '' : dir;
  return path.join(root, 'snippets', targetDir, outBase);
}

function toTemplateLiteralSafe(content) {
  return content.replaceAll("`", "\\`").replaceAll("${", "\\${");
}

function fileHeader(srcPath) {
  return `// AUTO-GENERATED by generate-snippets.js\n// Source: ${path.basename(srcPath)}\n// Do not edit this file directly.\n`;
}

function removeMarkedSections(content) {
  const lines = content.split(/\r?\n/);
  const result = [];
  let skipping = false;
  for (const line of lines) {
    if (line.includes('// Remove START') || line.includes('/* Remove START */')) {
      skipping = true;
      continue;
    }
    if (line.includes('// Remove END') || line.includes('/* Remove END */')) {
      skipping = false;
      continue;
    }
    if (!skipping && !line.includes('// Generate Snippet')) {
      result.push(line);
    }
  }
  return result.join('\n');
}

function stripExplanation(content) {
  let explanationValue = null;
  const explanationRegex = /^[^\S\r\n]*export const explanation\s*=\s*([\s\S]*?);\s*(?:\r?\n)?/m;
  const cleaned = content.replace(explanationRegex, (_, value) => {
      explanationValue = value.trim();
      return '';
  });
  return { content: cleaned, explanation: explanationValue };
}

function explanationNameFor(srcPath) {
  const base = path.basename(srcPath, path.extname(srcPath));
  const sanitized = base.replace(/[^0-9a-zA-Z_]/g, '_');
  const name = `${lowerFirst(sanitized)}Explanation`;
  return /^[a-zA-Z_$]/.test(name) ? name : `_${name}`;
}

function stripComponents(content, components) {
  if (!components.length) return content;
  let updated = content;
  for (const component of components) {
    updated = removeComponentOccurrences(updated, component);
  }
  return updated;
}

function removeComponentOccurrences(content, component) {
  let result = content;
  let start = findOpeningTagStart(result, component, 0);

  while (start !== -1) {
    const tagEnd = findTagEnd(result, start);
    if (tagEnd === -1) break;

    if (isSelfClosingTag(result, start, tagEnd)) {
      result = result.slice(0, start) + result.slice(tagEnd + 1);
      start = findOpeningTagStart(result, component, start);
      continue;
    }

    const blockEnd = findMatchingClose(result, component, tagEnd + 1);
    if (blockEnd === -1) break;

    result = result.slice(0, start) + result.slice(blockEnd);
    start = findOpeningTagStart(result, component, start);
  }

  return result;
}

function findOpeningTagStart(str, component, fromIndex) {
  const pattern = `<${component}`;
  let index = str.indexOf(pattern, fromIndex);
  while (index !== -1) {
    const boundary = str[index + pattern.length];
    if (isTagBoundary(boundary)) return index;
    index = str.indexOf(pattern, index + pattern.length);
  }
  return -1;
}

function findClosingTagStart(str, component, fromIndex) {
  const pattern = `</${component}`;
  let index = str.indexOf(pattern, fromIndex);
  while (index !== -1) {
    const boundary = str[index + pattern.length];
    if (isTagBoundary(boundary)) return index;
    index = str.indexOf(pattern, index + pattern.length);
  }
  return -1;
}

function findMatchingClose(str, component, fromIndex) {
  let searchIndex = fromIndex;
  let depth = 1;
  while (searchIndex < str.length) {
    const nextOpen = findOpeningTagStart(str, component, searchIndex);
    const nextClose = findClosingTagStart(str, component, searchIndex);

    if (nextClose === -1) return -1;

    if (nextOpen !== -1 && nextOpen < nextClose) {
      const openEnd = findTagEnd(str, nextOpen);
      if (openEnd === -1) return -1;
      if (!isSelfClosingTag(str, nextOpen, openEnd)) depth += 1;
      searchIndex = openEnd + 1;
      continue;
    }

    depth -= 1;
    const closeEnd = findTagEnd(str, nextClose);
    if (closeEnd === -1) return -1;
    if (depth === 0) return closeEnd + 1;
    searchIndex = closeEnd + 1;
  }
  return -1;
}

function findTagEnd(str, startIndex) {
  let cursor = startIndex + 1;
  let quote = null;
  while (cursor < str.length) {
    const ch = str[cursor];
    if (quote) {
      if (ch === '\\' && cursor + 1 < str.length) {
        cursor += 2;
        continue;
      }
      if (ch === quote) {
        quote = null;
      }
      cursor += 1;
      continue;
    }
    if (ch === '"' || ch === "'") {
      quote = ch;
      cursor += 1;
      continue;
    }
    if (ch === '{') {
      cursor = consumeBraces(str, cursor);
      continue;
    }
    if (ch === '`') {
      cursor = consumeTemplateString(str, cursor);
      continue;
    }
    if (ch === '>') return cursor;
    cursor += 1;
  }
  return -1;
}

function isSelfClosingTag(str, startIndex, endIndex) {
  for (let i = endIndex - 1; i > startIndex; i -= 1) {
    const ch = str[i];
    if (/\s/.test(ch)) continue;
    return ch === '/';
  }
  return false;
}

function isTagBoundary(ch) {
  return ch === undefined || /\s|\/|>/.test(ch);
}

function stripProperties(content, properties) {
  if (!properties.length) return content;
  const propertySet = new Set(properties);
  let i = 0;
  while (i < content.length) {
    const ch = content[i];
    if (!isIdentifierStart(ch)) {
      i += 1;
      continue;
    }

    let endName = i;
    while (endName < content.length && isIdentifierPart(content[endName])) {
      endName += 1;
    }

    const identifier = content.slice(i, endName);
    if (!propertySet.has(identifier)) {
      i = endName;
      continue;
    }

    const prevChar = i > 0 ? content[i - 1] : '';
    if (prevChar && !/\s|<|,/.test(prevChar)) {
      i = endName;
      continue;
    }

    let cursor = endName;
    while (cursor < content.length && /\s/.test(content[cursor])) cursor += 1;

    let endIndex = cursor;
    if (content[cursor] === '=') {
      cursor += 1;
      while (cursor < content.length && /\s/.test(content[cursor])) cursor += 1;
      endIndex = consumeAttributeValue(content, cursor);
    } else {
      endIndex = cursor;
    }

    let startIndex = i;
    while (startIndex > 0 && content[startIndex - 1] === ' ') {
      startIndex -= 1;
    }

    content = content.slice(0, startIndex) + content.slice(endIndex);
    i = startIndex;
  }

  return content;
}

function consumeAttributeValue(str, index) {
  if (index >= str.length) return index;
  const ch = str[index];
  if (ch === '"' || ch === "'") {
    return consumeQuotedString(str, index);
  }
  if (ch === '`') {
    return consumeTemplateString(str, index);
  }
  if (ch === '{') {
    return consumeBraces(str, index);
  }

  let cursor = index;
  while (cursor < str.length && !/\s|>|\//.test(str[cursor])) {
    cursor += 1;
  }
  return cursor;
}

function consumeQuotedString(str, index) {
  const quote = str[index];
  let cursor = index + 1;
  while (cursor < str.length) {
    const ch = str[cursor];
    if (ch === '\\') {
      cursor += 2;
      continue;
    }
    if (ch === quote) {
      cursor += 1;
      break;
    }
    cursor += 1;
  }
  return cursor;
}

function consumeTemplateString(str, index) {
  let cursor = index + 1;
  while (cursor < str.length) {
    const ch = str[cursor];
    if (ch === '\\') {
      cursor += 2;
      continue;
    }
    if (ch === '`') {
      cursor += 1;
      break;
    }
    if (ch === '$' && str[cursor + 1] === '{') {
      cursor = consumeBraces(str, cursor + 1);
      continue;
    }
    cursor += 1;
  }
  return cursor;
}

function consumeBraces(str, index) {
  let cursor = index + 1;
  let depth = 1;
  while (cursor < str.length && depth > 0) {
    const ch = str[cursor];
    if (ch === '\\') {
      cursor += 2;
      continue;
    }
    if (ch === '"' || ch === "'") {
      cursor = consumeQuotedString(str, cursor);
      continue;
    }
    if (ch === '`') {
      cursor = consumeTemplateString(str, cursor);
      continue;
    }
    if (ch === '{') depth += 1;
    else if (ch === '}') depth -= 1;
    cursor += 1;
  }
  return cursor;
}

function isIdentifierStart(ch) {
  return /[A-Za-z_$]/.test(ch);
}

function isIdentifierPart(ch) {
  return /[A-Za-z0-9_$-]/.test(ch);
}

async function writeSnippet(srcPath, outPath, body) {
  const header = fileHeader(srcPath);
  const fileText = `${header}\nconst snippet = \`${toTemplateLiteralSafe(body)}\`;\n\nexport default snippet;\n`;

  const prev = await fs.readFile(outPath, "utf8").catch(() => null);
  if (prev === fileText) return { outPath, status: "unchanged" };
  await fs.mkdir(path.dirname(outPath), { recursive: true });
  await fs.writeFile(outPath, fileText, "utf8");
  return { outPath, status: "written" };
}

async function writeExplanationsFile(root, explanationsMap) {
  if (!explanationsMap || !explanationsMap.size) return;
  const entries = Array.from(explanationsMap.entries()).sort(([a], [b]) => a.localeCompare(b));
  const lines = [
    `// AUTO-GENERATED by generate-snippets.js`,
    `// Contains explanation exports extracted from snippet sources`,
  ];

  for (const [, info] of entries) {
    lines.push(`//   ${path.relative(root, info.src)}`);
  }

  lines.push('');

  for (const [name, info] of entries) {
    lines.push(`export const ${name} = ${info.value};`);
  }

  lines.push('');

  const content = lines.join('\n');
  const formatted = await prettier.format(content, {
    parser: 'typescript',
    singleQuote: true,
    tabWidth: 4,
  });

  const explanationsPath = path.join(root, 'snippets', 'explanations.ts');
  await fs.mkdir(path.dirname(explanationsPath), { recursive: true });
  await fs.writeFile(explanationsPath, formatted, 'utf8');
}

async function processFile(root, file) {
  if (shouldSkip(file)) return null;
  const ext = path.extname(file);
  if (!exts.has(ext)) return null;

  const outPath = targetPathFor(root, file);
  if (!outPath) return null;

  try {
    let body = await fs.readFile(file, "utf8");
    const firstLine = body.split(/\r?\n/, 1)[0].trim();
    if (firstLine !== "// Generate Snippet") return null;

    const { content: contentWithoutExplanation, explanation } = stripExplanation(body);
    body = removeMarkedSections(contentWithoutExplanation);
    body = stripComponents(body, componentsToRemove);
    body = stripProperties(body, propertiesToRemove);
    body = await formatSnippetBody(body, ext);

    const result = await writeSnippet(file, outPath, body);
    const explanationExport = explanation
      ? { explanationValue: explanation, explanationName: explanationNameFor(file) }
      : {};
    return { src: file, out: outPath, ...result, ...explanationExport };
  } catch (err) {
    return { src: file, error: String(err) };
  }
}

(async () => {
  const results = [];
  const explanationsByRoot = new Map();
  for (const root of roots) {
    for await (const file of walk(root)) {
      const r = await processFile(root, file);
      if (r) {
        results.push(r);
        if (r.explanationValue) {
          if (!explanationsByRoot.has(root)) {
            explanationsByRoot.set(root, new Map());
          }
          explanationsByRoot
            .get(root)
            .set(r.explanationName, { value: r.explanationValue, src: r.src });
        }
      }
    }
  }

  for (const [root, explanationsMap] of explanationsByRoot.entries()) {
    await writeExplanationsFile(root, explanationsMap);
  }

  const grouped = results.reduce(
    (acc, r) => {
      if (r.error) acc.errors.push(r);
      else if (r.status === "written") acc.written.push(r);
      else if (r.status === "unchanged") acc.unchanged.push(r);
      return acc;
    },
    { written: [], unchanged: [], errors: [] }
  );

  const rel = (p) => path.relative(process.cwd(), p) || p;

  if (grouped.written.length) {
    console.log("\nCreated/Updated:");
    for (const r of grouped.written) console.log(`  ${rel(r.out)}  ←  ${rel(r.src)}`);
  }
  if (grouped.unchanged.length) {
    console.log("\nUnchanged:");
    for (const r of grouped.unchanged) console.log(`  ${rel(r.out)}  (from ${rel(r.src)})`);
  }
  if (grouped.errors.length) {
    console.error("\nErrors:");
    for (const r of grouped.errors) console.error(`  ${rel(r.src)}: ${r.error}`);
    process.exitCode = 1;
  }
})();
