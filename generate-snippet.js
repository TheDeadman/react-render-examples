#!/usr/bin/env node
// generate-snippets.js
// Usage:
//   node generate-snippets.js [paths...]
//
// This version only generates a snippet if the source file begins with:
//   // Generate Snippet
// and removes lines between comment pairs:
//   // Remove START
//   // Remove END

import { promises as fs } from 'node:fs';
import path from 'node:path';
import prettier from 'prettier';

function dataParserForExt(ext) {
  switch (ext) {
    case '.ts':
    case '.tsx':
      return 'typescript';
    case '.jsx':
      return 'babel';
    case '.js':
      return 'babel';
    default:
      return null;
  }
}

async function formatSnippetBody(content, ext) {
  const parser = dataParserForExt(ext);
  if (!parser) return content;

  try {
    return prettier.format(content, { parser, singleQuote: true, tabWidth: 4 });
  } catch {
    return content;
  }
}

const exts = new Set([".tsx", ".jsx", ".ts", ".js"]);
const now = new Date().toISOString();

const args = process.argv.slice(2);
const roots = args.length ? args : [process.cwd()];

async function* walk(dir) {
  const entries = await fs.readdir(dir, { withFileTypes: true });
  for (const entry of entries) {
    const res = path.join(dir, entry.name);
    if (entry.isDirectory()) {
      const lower = entry.name.toLowerCase();
      if (["node_modules", ".git", "dist", "build", ".next", "out", "snippets"].includes(lower)) continue;
      yield* walk(res);
    } else {
      yield res;
    }
  }
}

function looksLikeSnippetFile(file) {
  return /\.snippet\.ts$/i.test(file);
}

function shouldSkip(file) {
  const base = path.basename(file);
  if (looksLikeSnippetFile(base)) return true;
  if (/\.(test|spec)\./i.test(base)) return true;
  if (/\.stories\./i.test(base)) return true;
  if (/\.d\.ts$/i.test(base)) return true;
  return false;
}

function lowerFirst(s) {
  return s.length ? s[0].toLowerCase() + s.slice(1) : s;
}

function targetPathFor(root, srcPath) {
  const ext = path.extname(srcPath);
  if (!exts.has(ext)) return null;
  const relativePath = path.relative(root, srcPath);
  if (relativePath.startsWith('..')) return null;
  const dir = path.dirname(relativePath);
  const base = path.basename(relativePath, ext);
  const outBase = `${lowerFirst(base)}.snippet.ts`;
  const targetDir = dir === '.' ? '' : dir;
  return path.join(root, 'snippets', targetDir, outBase);
}

function toTemplateLiteralSafe(content) {
  return content.replaceAll("`", "\\`").replaceAll("${", "\\${");
}

function fileHeader(srcPath) {
  return `// AUTO-GENERATED by generate-snippets.js on ${now}\n// Source: ${path.basename(srcPath)}\n// Do not edit this file directly.\n`;
}

function removeMarkedSections(content) {
  const lines = content.split(/\r?\n/);
  const result = [];
  let skipping = false;
  for (const line of lines) {
    if (line.includes('// Remove START') || line.includes('/* Remove START */')) {
      skipping = true;
      continue;
    }
    if (line.includes('// Remove END') || line.includes('/* Remove END */')) {
      skipping = false;
      continue;
    }
    if (!skipping) {
      result.push(line);
    }
  }
  return result.join('\n');
}

function stripExplanation(content) {
  let explanationValue = null;
  const explanationRegex = /^[^\S\r\n]*export const explanation\s*=\s*([\s\S]*?);\s*(?:\r?\n)?/m;
  const cleaned = content.replace(explanationRegex, (_, value) => {
      explanationValue = value.trim();
      return '';
  });
  return { content: cleaned, explanation: explanationValue };
}

function explanationNameFor(srcPath) {
  const base = path.basename(srcPath, path.extname(srcPath));
  const sanitized = base.replace(/[^0-9a-zA-Z_]/g, '_');
  const name = `${lowerFirst(sanitized)}Explanation`;
  return /^[a-zA-Z_$]/.test(name) ? name : `_${name}`;
}

async function writeSnippet(srcPath, outPath, body) {
  const header = fileHeader(srcPath);
  const fileText = `${header}\nconst snippet = \`${toTemplateLiteralSafe(body)}\`;\n\nexport default snippet;\n`;

  const prev = await fs.readFile(outPath, "utf8").catch(() => null);
  if (prev === fileText) return { outPath, status: "unchanged" };
  await fs.mkdir(path.dirname(outPath), { recursive: true });
  await fs.writeFile(outPath, fileText, "utf8");
  return { outPath, status: "written" };
}

async function writeExplanationsFile(root, explanationsMap) {
  if (!explanationsMap || !explanationsMap.size) return;
  const entries = Array.from(explanationsMap.entries()).sort(([a], [b]) => a.localeCompare(b));
  const lines = [
    `// AUTO-GENERATED by generate-snippets.js on ${now}`,
    `// Contains explanation exports extracted from snippet sources`,
  ];

  for (const [, info] of entries) {
    lines.push(`//   ${path.relative(root, info.src)}`);
  }

  lines.push('');

  for (const [name, info] of entries) {
    lines.push(`export const ${name} = ${info.value};`);
  }

  lines.push('');

  const content = lines.join('\n');
  const formatted = await prettier.format(content, {
    parser: 'typescript',
    singleQuote: true,
    tabWidth: 4,
  });

  const explanationsPath = path.join(root, 'snippets', 'explanations.ts');
  await fs.mkdir(path.dirname(explanationsPath), { recursive: true });
  await fs.writeFile(explanationsPath, formatted, 'utf8');
}

async function processFile(root, file) {
  if (shouldSkip(file)) return null;
  const ext = path.extname(file);
  if (!exts.has(ext)) return null;

  const outPath = targetPathFor(root, file);
  if (!outPath) return null;

  try {
    let body = await fs.readFile(file, "utf8");
    const firstLine = body.split(/\r?\n/, 1)[0].trim();
    if (firstLine !== "// Generate Snippet") return null;

    const { content: contentWithoutExplanation, explanation } = stripExplanation(body);
    body = removeMarkedSections(contentWithoutExplanation);
    body = await formatSnippetBody(body, ext);

    const result = await writeSnippet(file, outPath, body);
    const explanationExport = explanation
      ? { explanationValue: explanation, explanationName: explanationNameFor(file) }
      : {};
    return { src: file, out: outPath, ...result, ...explanationExport };
  } catch (err) {
    return { src: file, error: String(err) };
  }
}

(async () => {
  const results = [];
  const explanationsByRoot = new Map();
  for (const root of roots) {
    for await (const file of walk(root)) {
      const r = await processFile(root, file);
      if (r) {
        results.push(r);
        if (r.explanationValue) {
          if (!explanationsByRoot.has(root)) {
            explanationsByRoot.set(root, new Map());
          }
          explanationsByRoot
            .get(root)
            .set(r.explanationName, { value: r.explanationValue, src: r.src });
        }
      }
    }
  }

  for (const [root, explanationsMap] of explanationsByRoot.entries()) {
    await writeExplanationsFile(root, explanationsMap);
  }

  const grouped = results.reduce(
    (acc, r) => {
      if (r.error) acc.errors.push(r);
      else if (r.status === "written") acc.written.push(r);
      else if (r.status === "unchanged") acc.unchanged.push(r);
      return acc;
    },
    { written: [], unchanged: [], errors: [] }
  );

  const rel = (p) => path.relative(process.cwd(), p) || p;

  if (grouped.written.length) {
    console.log("\nCreated/Updated:");
    for (const r of grouped.written) console.log(`  ${rel(r.out)}  ‚Üê  ${rel(r.src)}`);
  }
  if (grouped.unchanged.length) {
    console.log("\nUnchanged:");
    for (const r of grouped.unchanged) console.log(`  ${rel(r.out)}  (from ${rel(r.src)})`);
  }
  if (grouped.errors.length) {
    console.error("\nErrors:");
    for (const r of grouped.errors) console.error(`  ${rel(r.src)}: ${r.error}`);
    process.exitCode = 1;
  }
})();
